# 判断素数

素数： 大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。

刚接触编程的时候遇到这个问题就只想到，根据素数的定义，从 `2` 到 `sqrt(n)` 遍历看看有没有哪个数能整除 n 。如果有说明不是素数，

```js
function isPrime(n) {
  if (n <= 3) {
    return n > 1;
  }
  var sqrt = Math.sqrt(n);
  for (let i = 2; i <= sqrt; i++) {
    if (n % i === 0) {
      return false;
    }
  }
  return true;
}
```



后来工作中也没遇到过这样的实际问题，所以也没再想过，最近网上发现一些别的算法，大概是这样的

以 6 为基础，数字可以表示为 6x, 6x + 1, 6x + 2, 6x + 3, 6x + 4, 6x + 5。这其中只有 6x + 1, 6x + 5（6x - 1） 有可能是素数，其它的数字要么是 2 的倍数，要么是 3 的倍数，都不可能是素数。也就是说素数一定只能出现在 6 的倍数的一左一右这两个位置，但是这个位置上的数也不都是素数，比如 25 = 6 x 4 + 1。却不是素数。

有此结论，只要在循环前面加上判断，可能就提前判断不是素数了。

```js
if (n % 6 !== 1 && n % 6 ！== 5) {
  return false;
}
```

不过这个判断的帮助并不大，如果经过计算 n 在这里提前返回了，说明 n 是 2 或者 3 的倍数，即使没有这层判断到了下面的循环，也就是第一次或者第二次的时候就可以退出循环，得到结果了。

最糟糕的结果是如果 n 是一个比较大的素数 p 的平方，那么循环就要一直执行到 p 这里才能发现 n 不是素数，如果能减少这里面的遍历，对程序的优化应该是有明显帮助的

这里需要用到一个基本定理： 合数可以拆成多个素数的积

所以在遍历的时候，小于 p 的合数就直接跳过吧，只判断那些可能是素数的位置就好了，也就是 6x - 1 和 6x + 1 的地方，如此一来要判断的数字就变成之前的三分之一了。

```js
for (let i = 5; i <= sqrt; i += 6) {
  if (n % i === 0 || n % (i + 2) === 0) {
    return false;
  }
}
return true;
```

