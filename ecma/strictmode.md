
An ECMAScript Script syntactic unit may be processed using either unrestricted or strict mode syntax and semantics. Code is interpreted as strict mode code in the following situations:
- Global code is strict mode code if it begins with a [Directive Prologue](https://www.ecma-international.org/ecma-262/10.0/index.html#directive-prologue) that contains a [Use Strict Directive](https://www.ecma-international.org/ecma-262/10.0/index.html#use-strict-directive).
- Module code is always strict mode code.
- All parts of a ClassDeclaration or a ClassExpression are strict mode code.
- Eval code is strict mode code if it begins with a Directive Prologue that contains a Use Strict Directive or if the call to eval is a direct eval that is contained in strict mode code.
- Function code is strict mode code if the associated FunctionDeclaration, FunctionExpression, GeneratorDeclaration, GeneratorExpression, AsyncFunctionDeclaration, AsyncFunctionExpression, AsyncGeneratorDeclaration, AsyncGeneratorExpression, MethodDefinition, ArrowFunction, or AsyncArrowFunction is contained in strict mode code or if the code that produces the value of the function's [[ECMAScriptCode]] internal slot begins with a Directive Prologue that contains a Use Strict Directive.
- Function code that is supplied as the arguments to the built-in Function, Generator, AsyncFunction, and AsyncGenerator constructors is strict mode code if the last argument is a String that when processed is a FunctionBody that begins with a Directive Prologue that contains a Use Strict Directive.



The strict mode restriction and exceptions:
- **implements, interface, let, package, private, protected, public, static**, and **yield** are reserved words within strict mode code
- A conforming implementation, when processing strict mode code, must not extend, as described in B.1.1, the syntax of *[NumericLiteral](https://tc39.es/ecma262/#prod-NumericLiteral)* to include *[LegacyOctalIntegerLiteral](https://tc39.es/ecma262/#prod-annexB-LegacyOctalIntegerLiteral)*, nor extend the syntax of *[DecimalIntegerLiteral](https://tc39.es/ecma262/#prod-DecimalIntegerLiteral)* to include *[NonOctalDecimalIntegerLiteral](https://tc39.es/ecma262/#prod-annexB-NonOctalDecimalIntegerLiteral)*.
- A conforming implementation, when processing strict mode code, may not extend the syntax of *[EscapeSequence](https://tc39.es/ecma262/#prod-EscapeSequence)* to include *[LegacyOctalEscapeSequence](https://tc39.es/ecma262/#prod-annexB-LegacyOctalEscapeSequence)* as described in [B.1.2](https://tc39.es/ecma262/#sec-additional-syntax-string-literals).
- Assignment to an undeclared identifier or otherwise unresolvable reference does not create a property in the global object. When a simple assignment occurs within strict mode code, its LeftHandSideExpression must not evaluate to an unresolvable Reference. If it does a **ReferenceError** exception is thrown . The LeftHandSideExpression also may not be a reference to a data property with the attribute value { \[[Writable]]: false }, to an accessor property with the attribute value { \[[Set]]: undefined }, nor to a non-existent property of an object whose \[[Extensible]] internal slot has the value false. In these cases a **TypeError** exception is thrown.
- An *IdentifierReference* with the StringValue **"eval"** or **"arguments"** may not appear as the *LeftHandSideExpression* of an Assignment operator (12.15) or of an *UpdateExpression* (12.4) or as the *UnaryExpression* operated upon by a Prefix Increment (12.4.6) or a Prefix Decrement (12.4.7) operator.
- Arguments objects for strict functions define a non-configurable accessor property "callee" which throws a TypeError exception on access (9.4.4.6).
- Arguments objects for strict functions do not dynamically share their array-indexed property values with the corresponding formal parameter bindings of their functions. 
- For strict functions, if an arguments object is created the binding of the local identifier arguments to the arguments object is immutable and hence may not be the target of an assignment expression. 
- It is a SyntaxError if the StringValue of a BindingIdentifier is "eval" or "arguments" within strict mode code
- Strict mode eval code cannot instantiate variables or functions in the variable environment of the caller to eval. Instead, a new variable environment is created and that environment is used for declaration binding instantiation for the eval code 
- If this is evaluated within strict mode code, then the this value is not coerced to an object. A this value of undefined or null is not converted to the global object and primitive values are not converted to wrapper objects. The this value passed via a function call (including calls made using Function.prototype.apply and Function.prototype.call) do not coerce the passed this value to an object
- When a delete operator occurs within strict mode code, a SyntaxError is thrown if its UnaryExpression is a direct reference to a variable, function argument, or function name
- When a delete operator occurs within strict mode code, a TypeError is thrown if the property to be deleted has the attribute { \[[Configurable]]: false } 
- Strict mode code may not include a WithStatement. The occurrence of a WithStatement in such a context is a SyntaxError
- It is a SyntaxError if a CatchParameter occurs within strict mode code and BoundNames of CatchParameter contains either eval or arguments
- It is a SyntaxError if the same BindingIdentifier appears more than once in the FormalParameters of a strict function. An attempt to create such a function using a Function, Generator, or AsyncFunction constructor is a SyntaxError
- An implementation may not extend, beyond that defined in this specification, the meanings within strict functions of properties named "caller" or "arguments" of function instances
